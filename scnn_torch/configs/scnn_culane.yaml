# SCNN Configuration for CULane Dataset

# Model
model:
  ms_ks: 9                # Message passing kernel size
  pretrained: true

# Dataset
dataset:
  root: data/CULane
  resize_shape: [288, 800]  # [height, width] - preprocessing only, not model constraint

# Dataloader
dataloader:
  batch_size: 8  # 32  if resources allow
  num_workers: 4  # 20  for batch size 32

# Training
train:
  max_iter: 128000  # 32000 for batch size 32

# Augmentation
augmentation:
  rotation: 2.0  # Rotation theta in degrees (samples from [-theta/2, theta/2], always applied)

# Optimizer
optimizer:
  type: SGD
  lr: 0.01  # 0.04 for batch size 32
  momentum: 0.9
  weight_decay: 0.001
  nesterov: true

# Learning rate scheduler
lr_scheduler:
  power: 0.9
  warmup: 800  # 200 for batch size 32
  min_lr: 1.0e-20

# Loss
loss:
  seg_weight: 1.0
  exist_weight: 0.1
  background_weight: 0.4

# Normalization (ImageNet statistics - for pretrain model)
normalize:
  mean: [0.485, 0.456, 0.406]
  std: [0.229, 0.224, 0.225]
# Normalization (CULane dataset statistics - for training from scratch)
# normalize:
#   mean: [0.3598, 0.3723, 0.3771]
#   std: [0.2772, 0.2915, 0.3087]

# Checkpoints (save checkpoint with validation every N iterations)
checkpoint:
  save_dir: checkpoints
  interval: 2000  # 500 for batch size 32

# Logging
logging:
  print_interval: 100  # Print every N iterations

# Evaluation
evaluation:
  # Post-processing parameters (convert probability maps to lane coordinates)
  y_px_gap: 20               # Y-axis sampling interval in pixels
  pts: 18                    # Number of points to sample per lane
  thresh: 0.3                # Probability threshold for lane detection

  # Evaluation parameters (for tools/evaluate.py)
  iou_threshold: 0.5         # IoU threshold for lane matching
  lane_width: 30             # Lane width in pixels for drawing/evaluation
